//TEST_1:棋盘初始化测试
	/*
	SPACE chessboard[LENGTH][LENGTH];
	set_individual_chessboard(chessboard);
	printf("%d %d %d", chessboard[1][2].x, chessboard[5][6].y, chessboard[2][2].belong);
	*/
//TEST_2:打印棋盘测试
	/*
	SPACE chessboard[LENGTH][LENGTH];
	set_individual_chessboard(chessboard);
	print_chessboard(chessboard);
	*/
//TEST_3:隐藏光标测试
	/*
	SPACE chessboard[LENGTH][LENGTH];
	set_individual_chessboard(chessboard);
	print_chessboard(chessboard);
	*/
//TEST_4:人类默认执黑落子测试(未进行无法落子情况检验）
	/*
	SPACE chessboard[LENGTH][LENGTH];
	set_individual_chessboard(chessboard);
	print_chessboard(chessboard);
	int x, y;
	scanf_s("%d%d", &x, &y);
	human_player_play(x, y, chessboard);
	print_chessboard(chessboard);
	*/
//TEST_5:人类开局随机获得先后手并告知，并直接进行一次落子(未进行无法落子情况检验）
	/*
	srand((unsigned int)time(NULL));
	int color = before_begin();
	SPACE chessboard[LENGTH][LENGTH];
	set_individual_chessboard(chessboard);
	print_chessboard(chessboard);
	int x, y;
	scanf_s("%d%d", &x, &y);
	human_player_play(x, y, chessboard,color);
	print_chessboard(chessboard);
	*/
//TEST_6:重复落子情况检验
	///*
	srand((unsigned int)time(NULL));
	int color = before_begin();
	SPACE chessboard[LENGTH][LENGTH];
	set_individual_chessboard(chessboard);
	print_chessboard(chessboard);
	int x, y;
	scanf_s("%d%d", &x, &y);
	human_player_play(x, y, chessboard,color);
	print_chessboard(chessboard);
	scanf_s("%d%d", &x, &y);
	human_player_play(x, y, chessboard, color);
	print_chessboard(chessboard);
	//*/
//TEST_7:用随机落子模拟AI落子,进行轮流落子
	///*
	srand((unsigned int)time(NULL));
	int color = before_begin();
	SPACE chessboard[LENGTH][LENGTH];
	set_individual_chessboard(chessboard);
	print_chessboard(chessboard);
	int x, y;
	if(color==WHITE){
		AI_player_play(chessboard, BLACK);
		print_chessboard(chessboard);
	}
	int AI_color = (color == WHITE) ? BLACK : WHITE;
	while (1) {
		scanf_s("%d%d", &x, &y);
		human_player_play(x, y, chessboard, color);
		print_chessboard(chessboard);
		AI_player_play(chessboard, AI_color);
		print_chessboard(chessboard);
	}
	//*/
//TEST_8:测试胜利判定
	///*
	srand((unsigned int)time(NULL));
	int color = before_begin();
	SPACE chessboard[LENGTH][LENGTH];
	set_individual_chessboard(chessboard);
	print_chessboard(chessboard);
	int x, y;
	if(color==WHITE){
		AI_player_play(chessboard, BLACK);
		print_chessboard(chessboard);
	}
	int AI_color = (color == WHITE) ? BLACK : WHITE;
	while (1) {
		scanf_s("%d%d", &x, &y);
		human_player_play(x, y, chessboard, color);
		print_chessboard(chessboard);
		if(color==victory_condition(chessboard)){
			printf("You Win!\n");
			break;
		}
		AI_player_play(chessboard, AI_color);
		print_chessboard(chessboard);
		if (AI_color == victory_condition(chessboard)) {
			printf("AI Win!\n");
			break;
		}
	}
	//*/

//TEST_9:对set_individual_chessboard产生疑惑，于是测试
	
	srand((unsigned int)time(NULL));
	int color = before_begin();
	SPACE chessboard[LENGTH][LENGTH];
	set_individual_chessboard(chessboard);
	printf("%d\n", chessboard[0][0].score);
	printf("%d\n", chessboard[4][8].y);
	printf("%d\n", chessboard[5][7].belong);
	system("pause");
	print_chessboard(chessboard);
//TEST_10:检验evaluate_score附属函数check_continue_heng
///*
	srand((unsigned int)time(NULL));
	int color = before_begin();
	SPACE chessboard[LENGTH][LENGTH];
	set_individual_chessboard(chessboard);
	print_chessboard(chessboard);
	int x, y;
	if (color == WHITE) {
		AI_player_play(chessboard, BLACK);
		print_chessboard(chessboard);
	}
	int AI_color = (color == WHITE) ? BLACK : WHITE;
	while (1) {
		scanf_s("%d%d", &x, &y);
		human_player_play(x, y, chessboard, color);
		printf("%d\n", check_continue_heng(chessboard[x][y], chessboard));
		//Sleep("2000");
		print_chessboard(chessboard);
		
		if (color == victory_condition(chessboard)) {
			printf("You Win!\n");
			break;
		}
		AI_player_play(chessboard, AI_color);
		print_chessboard(chessboard);
		if (AI_color == victory_condition(chessboard)) {
			printf("AI Win!\n");
			break;
		}
	}
	//*/
//TEST_11:检验evaluate_score四个附属函数
///*
	srand((unsigned int)time(NULL));
	int color = before_begin();
	SPACE chessboard[LENGTH][LENGTH];
	set_individual_chessboard(chessboard);
	print_chessboard(chessboard);
	int x, y;
	if (color == WHITE) {
		AI_player_play(chessboard, BLACK);
		print_chessboard(chessboard);
	}
	int AI_color = (color == WHITE) ? BLACK : WHITE;
	while (1) {
		scanf_s("%d%d", &x, &y);
		human_player_play(x, y, chessboard, color);
		printf("%d\n", check_continue_heng(chessboard[x][y], chessboard));
		printf("%d\n", check_continue_shu(chessboard[x][y], chessboard));
		printf("%d\n", check_continue_pie(chessboard[x][y], chessboard));
		printf("%d\n", check_continue_na(chessboard[x][y], chessboard));
		system("pause");
		print_chessboard(chessboard);
		
		if (color == victory_condition(chessboard)) {
			printf("You Win!\n");
			break;
		}
		AI_player_play(chessboard, AI_color);
		print_chessboard(chessboard);
		if (AI_color == victory_condition(chessboard)) {
			printf("AI Win!\n");
			break;
		}
	}
	//*/
//TEST_12:讲四个价值评估附属函数从Int类型改为同时返回数和是否是活的(返回三个值，
	// 一个表示连续数，两个表示左右两端是否被赌，
	//补充了棋的类型，新增“冲”，“死”两个类型
///*
	srand((unsigned int)time(NULL));
	int color = before_begin();
	SPACE chessboard[LENGTH][LENGTH];
	set_individual_chessboard(chessboard);
	print_chessboard(chessboard);
	int x, y;
	if (color == WHITE) {
		AI_player_play(chessboard, BLACK);
		print_chessboard(chessboard);
	}
	int AI_color = (color == WHITE) ? BLACK : WHITE;
	while (1) {
		scanf_s("%d%d", &x, &y);
		human_player_play(x, y, chessboard, color);
		printf("%d\t%d\t%d\n", check_continue_heng(chessboard[x][y], chessboard).num, check_continue_heng(chessboard[x][y], chessboard).live_1, check_continue_heng(chessboard[x][y], chessboard).live_2);
		printf("%d\t%d\t%d\n", check_continue_shu(chessboard[x][y], chessboard).num, check_continue_shu(chessboard[x][y], chessboard).live_1, check_continue_shu(chessboard[x][y], chessboard).live_2);
		printf("%d\t%d\t%d\n", check_continue_pie(chessboard[x][y], chessboard).num, check_continue_pie(chessboard[x][y], chessboard).live_1, check_continue_pie(chessboard[x][y], chessboard).live_2);
		printf("%d\t%d\t%d\n", check_continue_na(chessboard[x][y], chessboard).num, check_continue_na(chessboard[x][y], chessboard).live_1, check_continue_na(chessboard[x][y], chessboard).live_2);
		system("pause");
		print_chessboard(chessboard);
		
		if (color == victory_condition(chessboard)) {
			printf("You Win!\n");
			break;
		}
		AI_player_play(chessboard, AI_color);
		print_chessboard(chessboard);
		if (AI_color == victory_condition(chessboard)) {
			printf("AI Win!\n");
			break;
		}
	}
	//*/
	//TEST_13:完成evaluate_score,书写过程中发现“冲”类型需要另外来写，涉及到假设落子该点，那么得分变化会如何，之后再另外讨论
///*
	srand((unsigned int)time(NULL));
	int color = before_begin();
	SPACE chessboard[LENGTH][LENGTH];
	set_individual_chessboard(chessboard);
	print_chessboard(chessboard);
	int x, y;
	if (color == WHITE) {
		AI_player_play(chessboard, BLACK);
		print_chessboard(chessboard);
	}
	int AI_color = (color == WHITE) ? BLACK : WHITE;
	while (1) {
		scanf_s("%d%d", &x, &y);
		human_player_play(x, y, chessboard, color);
		printf("%d\n", evaluate_score(chessboard[x][y], chessboard));
		system("pause");
		print_chessboard(chessboard);
		
		if (color == victory_condition(chessboard)) {
			printf("You Win!\n");
			break;
		}
		AI_player_play(chessboard, AI_color);
		print_chessboard(chessboard);
		if (AI_color == victory_condition(chessboard)) {
			printf("AI Win!\n");
			break;
		}
	}
	//*/
//TEST_14:初次尝试AI落子――――遍历场上所有可落子位置，评估每一处落子的己方分数，选取最高处落子，并成功修改了wvaluate_score.c中的一些逻辑bug和缺漏
///*
	srand((unsigned int)time(NULL));
	int color = before_begin();
	SPACE chessboard[LENGTH][LENGTH];
	set_individual_chessboard(chessboard);
	print_chessboard(chessboard);
	int x, y;
	if (color == WHITE) {
		chessboard[7][7].belong = BLACK;
		print_chessboard(chessboard);
	}
	int AI_color = (color == WHITE) ? BLACK : WHITE;
	while (1) {
		scanf_s("%d%d", &x, &y);
		human_player_play(x, y, chessboard, color);
		print_chessboard(chessboard);
		
		if (color == victory_condition(chessboard)) {
			printf("You Win!\n");
			break;
		}
		AI_player_play(chessboard, AI_color);
		print_chessboard(chessboard);
		if (AI_color == victory_condition(chessboard)) {
			printf("AI Win!\n");
			break;
		}
	}
	//*/
//TEST_15:将test14中完成的ai落子策略命名为进攻策略，并完成防守落子策略
///*
	srand((unsigned int)time(NULL));
	int color = before_begin();
	SPACE chessboard[LENGTH][LENGTH];
	set_individual_chessboard(chessboard);
	print_chessboard(chessboard);
	int x, y;
	if (color == WHITE) {
		chessboard[7][7].belong = BLACK;
		print_chessboard(chessboard);
	}
	int AI_color = (color == WHITE) ? BLACK : WHITE;
	while (1) {
		scanf_s("%d%d", &x, &y);
		human_player_play(x, y, chessboard, color);
		print_chessboard(chessboard);
		
		if (color == victory_condition(chessboard)) {
			printf("You Win!\n");
			break;
		}
		AI_player_defense(chessboard, AI_color);
		print_chessboard(chessboard);
		if (AI_color == victory_condition(chessboard)) {
			printf("AI Win!\n");
			break;
		}
	}
	//*/
//TEST_16:完成局面评估系统，评估当前局面谁为优势方,优势或者均势时进攻，劣势时防守
///*
	srand((unsigned int)time(NULL));
	int color = before_begin();
	SPACE chessboard[LENGTH][LENGTH];
	set_individual_chessboard(chessboard);
	print_chessboard(chessboard);
	int x, y;
	if (color == WHITE) {
		chessboard[7][7].belong = BLACK;
		print_chessboard(chessboard);
	}
	int AI_color = (color == WHITE) ? BLACK : WHITE;
	while (1) {
		scanf_s("%d%d", &x, &y);
		human_player_play(x, y, chessboard, color);
		print_chessboard(chessboard);
		
		if (color == victory_condition(chessboard)) {
			printf("You Win!\n");
			break;
		}
		if (situation_assessment(chessboard, AI_color) >= 0) {
			AI_player_offense(chessboard, AI_color);
		}
		else {
			AI_player_defense(chessboard, AI_color);
		}
		print_chessboard(chessboard);
		if (AI_color == victory_condition(chessboard)) {
			printf("AI Win!\n");
			break;
		}
	}
	//*/
//TEST_17:完成“冲”类型,为了鼓励AI进攻，当其执黑时，局面评估分额外加100,并调试了各类棋型的分值
///*
	srand((unsigned int)time(NULL));
	int color = before_begin();
	SPACE chessboard[LENGTH][LENGTH];
	set_individual_chessboard(chessboard);
	print_chessboard(chessboard);
	int x, y;
	if (color == WHITE) {
		chessboard[7][7].belong = BLACK;
		print_chessboard(chessboard);
	}
	int AI_color = (color == WHITE) ? BLACK : WHITE;
	while (1) {
		scanf_s("%d%d", &x, &y);
		human_player_play(x, y, chessboard, color);
		print_chessboard(chessboard);
		
		if (color == victory_condition(chessboard)) {
			printf("You Win!\n");
			break;
		}
		printf("%d\n", situation_assessment(chessboard, AI_color));
		system("pause");
		if (situation_assessment(chessboard, AI_color) >= 0) {
			AI_player_offense(chessboard, AI_color);
		}
		else {
			AI_player_defense(chessboard, AI_color);
		}
		print_chessboard(chessboard);
		if (AI_color == victory_condition(chessboard)) {
			printf("AI Win!\n");
			break;
		}
	}
	//*/
//TEST_18:当AI执黑时，将落子位置从7，7改为在以7，7为中心的3*3空间内随机落子
	//同时，为了增加AI落子的随机性，将选取当前局面最优的三个落子位置，按照轮盘赌随机落子,但是此方案最终取消，以避免必应落子由于随机数而未应答
	//贪心算法策略完成
///*
	srand((unsigned int)time(NULL));
	int color = before_begin();
	SPACE chessboard[LENGTH][LENGTH];
	set_individual_chessboard(chessboard);
	print_chessboard(chessboard);
	int x, y;
	if (color == WHITE) {
		int x_rand = rand() % 3 + 6, y_rand = rand() % 3 + 6;
		chessboard[x_rand][y_rand].belong = BLACK;
		print_chessboard(chessboard);
	}
	int AI_color = (color == WHITE) ? BLACK : WHITE;
	while (1) {
		scanf_s("%d%d", &x, &y);
		human_player_play(x, y, chessboard, color);
		print_chessboard(chessboard);
		
		if (color == victory_condition(chessboard)) {
			printf("You Win!\n");
			break;
		}
		printf("%d\n", situation_assessment(chessboard, AI_color));
		system("pause");
		if (situation_assessment(chessboard, AI_color) >= 0) {
			AI_player_offense(chessboard, AI_color);
		}
		else {
			AI_player_defense(chessboard, AI_color);
		}
		print_chessboard(chessboard);
		if (AI_color == victory_condition(chessboard)) {
			printf("AI Win!\n");
			break;
		}
	}
	//*/
//TEST_19:DFS策略，alpha-beta剪枝，evaluate_score函数重构升级，用了AI改进很多次，对各个改进版本备案
///*
	srand((unsigned int)time(NULL));
	int color = before_begin();
	SPACE chessboard[LENGTH][LENGTH];
	set_individual_chessboard(chessboard);
	print_chessboard(chessboard);
	int x, y;
	if (color == WHITE) {
		int x_rand = rand() % 3 + 6, y_rand = rand() % 3 + 6;
		chessboard[x_rand][y_rand].belong = BLACK;
		print_chessboard(chessboard);
	}
	int AI_color = (color == WHITE) ? BLACK : WHITE;
	while (1) {
		scanf_s("%d%d", &x, &y);
		human_player_play(x, y, chessboard, color);
		print_chessboard(chessboard);
		
		if (color == victory_condition(chessboard)) {
			printf("You Win!\n");
			break;
		}
		//printf("%d\n", situation_assessment(chessboard, AI_color));
		//system("pause");
		/*
		if (situation_assessment(chessboard, AI_color) >= 0) {
			AI_player_offense(chessboard, AI_color);
		}
		else {
			AI_player_defense(chessboard, AI_color);
		}
		*/
		AI_player_optimized(chessboard, AI_color);
		print_chessboard(chessboard);
		if (AI_color == victory_condition(chessboard)) {
			printf("AI Win!\n");
			break;
		}
	}
	//*/

	//TEST_20:重新简化调整alpha_beta函数，各棋形分值回归原来值，evaluate.c回归原先
	//增加了一个输入保护机制：避免输入落子位置时故意或者有意输入了棋盘外的点位导致栈溢出
	//将搜索深度设置为4后，并且修改了一些棋类的分值，可以避免很多情况下AI下棋的弱智行为，但并未完全杜绝其发生。
	//发现在将搜索深度设置为4后，直接删去危机棋形应急应对策略，发现反而不会出现弱智行为了
	//尝试将原先AI执黑时在中心九格随机落子删去，同质化使用AIalpha-beta函数，但发现AI会稳定的落子在（6，6），于是取消此想法，并将范围扩大到中心25格
	//新增AI落子后告知玩家落子位置，并提示玩家走棋
	//用Release模式代替Debug模式运行速度会提升多倍，甚至一个数量级
///*
	srand((unsigned int)time(NULL));
	int color = before_begin();
	SPACE chessboard[LENGTH][LENGTH];
	set_individual_chessboard(chessboard);
	print_chessboard(chessboard);
	int x, y;
	if (color == WHITE) {
		int x_rand = rand() % 5 + 4, y_rand = rand() % 5 + 4;
		chessboard[x_rand][y_rand].belong = BLACK;
		print_chessboard(chessboard);
		printf("AI choose stone place(%d,%d).\n", x_rand, y_rand);
		printf("It's your turn!\n");
	}
	int AI_color = (color == WHITE) ? BLACK : WHITE;
	while (1) {
		scanf_s("%d%d", &x, &y);
		human_player_play(x, y, chessboard, color);
		print_chessboard(chessboard);
		if (color == victory_condition(chessboard)) {
			printf("You Win!\n");
			break;
		}
		SPACE AI=AI_player_optimized(chessboard, AI_color);
		print_chessboard(chessboard);
		if (AI_color == victory_condition(chessboard)) {
			printf("AI Win!\n");
			break;
		}
		printf("AI choose stone place(%d,%d).\n", AI.x, AI.y);
		printf("It's your turn!\n");
	}
	//*/
//TEST_21:“冲字模型有点问题――冲也应该有死活之分，对于威胁程度不同
	//改进方案为利用live_1,live_2,但发现有问题，遂想增添结构体内含变量
	//对evaluate函数进行了较多改动，以减少“重复的味道”，但是这个.c文件的重复味道应该还是很浓郁的
	//新增游戏结束时弹出提框的功能
///*
	srand((unsigned int)time(NULL));
	int color = before_begin();
	SPACE chessboard[LENGTH][LENGTH];
	set_individual_chessboard(chessboard);
	print_chessboard(chessboard);
	int x, y;
	if (color == WHITE) {
		int x_rand = rand() % 5 + 4, y_rand = rand() % 5 + 4;
		chessboard[x_rand][y_rand].belong = BLACK;
		print_chessboard(chessboard);
		printf("AI choose stone place(%d,%d).\n", x_rand, y_rand);
		printf("It's your turn!\n");
	}
	int AI_color = (color == WHITE) ? BLACK : WHITE;
	while (1) {
		scanf_s("%d%d", &x, &y);
		human_player_play(x, y, chessboard, color);
		print_chessboard(chessboard);
		if (color == victory_condition(chessboard)) {
			printf("You Win!\n");
			MessageBox(0, TEXT("You win! Congratulations!"), TEXT("GameOver"), NULL);
			break;
		}
		SPACE AI=AI_player_optimized(chessboard, AI_color);
		print_chessboard(chessboard);
		if (AI_color == victory_condition(chessboard)) {
			printf("AI Win!\n");
			MessageBox(0, TEXT("You lost! What a pity!"), TEXT("GameOver"), NULL);
			break;
		}
		printf("AI choose stone place(%d,%d).\n", AI.x, AI.y);
		printf("It's your turn!\n");
	}
	//*/
//TEST_22:优化了一下ALPHA_BETA函数
///*
	srand((unsigned int)time(NULL));
	int color = before_begin();
	SPACE chessboard[LENGTH][LENGTH];
	set_individual_chessboard(chessboard);
	print_chessboard(chessboard);
	int x, y;
	if (color == WHITE) {
		int x_rand = rand() % 5 + 4, y_rand = rand() % 5 + 4;
		chessboard[x_rand][y_rand].belong = BLACK;
		print_chessboard(chessboard);
		printf("AI choose stone place(%d,%d).\n", x_rand, y_rand);
		printf("It's your turn!\n");
	}
	int AI_color = (color == WHITE) ? BLACK : WHITE;
	while (1) {
		scanf_s("%d%d", &x, &y);
		human_player_play(x, y, chessboard, color);
		print_chessboard(chessboard);
		if (color == victory_condition(chessboard)) {
			printf("You Win!\n");
			MessageBox(0, TEXT("You win! Congratulations!"), TEXT("GameOver"), NULL);
			break;
		}
		SPACE AI=AI_player_optimized(chessboard, AI_color);
		print_chessboard(chessboard);
		if (AI_color == victory_condition(chessboard)) {
			printf("AI Win!\n");
			MessageBox(0, TEXT("You lost! What a pity!"), TEXT("GameOver"), NULL);
			break;
		}
		printf("AI choose stone place(%d,%d).\n", AI.x, AI.y);
		printf("It's your turn!\n");
	}
	//*/
//TEST_24:优化了UI，新增落子规范示例，新增按'b'确定启动游戏，而不是短暂的暂停然后自动启动游戏
///*
	srand((unsigned int)time(NULL));
	int color = before_begin();
	SPACE chessboard[LENGTH][LENGTH];
	set_individual_chessboard(chessboard);
	print_chessboard(chessboard);
	int x, y;
	if (color == WHITE) {
		int x_rand = rand() % 5 + 4, y_rand = rand() % 5 + 4;
		chessboard[x_rand][y_rand].belong = BLACK;
		print_chessboard(chessboard);
		printf("AI choose stone place(%d,%d).\n", x_rand, y_rand);
		printf("It's your turn!\n");
	}
	int AI_color = (color == WHITE) ? BLACK : WHITE;
	while (1) {
		scanf_s("%d%d", &x, &y);
		human_player_play(x, y, chessboard, color);
		print_chessboard(chessboard);
		if (color == victory_condition(chessboard)) {
			printf("You Win!\n");
			MessageBox(0, TEXT("You win! Congratulations!"), TEXT("GameOver"), NULL);
			break;
		}
		SPACE AI=AI_player_optimized(chessboard, AI_color);
		print_chessboard(chessboard);
		if (AI_color == victory_condition(chessboard)) {
			printf("AI Win!\n");
			MessageBox(0, TEXT("You lost! What a pity!"), TEXT("GameOver"), NULL);
			break;
		}
		printf("AI choose stone place(%d,%d).\n", AI.x, AI.y);
		printf("It's your turn!\n");
	}
	//*/
//TEST_25:优化了SPACE结构，其中的score已经无用
///*
	srand((unsigned int)time(NULL));
	int color = before_begin();
	SPACE chessboard[LENGTH][LENGTH];
	set_individual_chessboard(chessboard);
	print_chessboard(chessboard);
	int x, y;
	if (color == WHITE) {
		int x_rand = rand() % 5 + 4, y_rand = rand() % 5 + 4;
		chessboard[x_rand][y_rand].belong = BLACK;
		print_chessboard(chessboard);
		printf("AI choose stone place(%d,%d).\n", x_rand, y_rand);
		printf("It's your turn!\n");
	}
	int AI_color = (color == WHITE) ? BLACK : WHITE;
	while (1) {
		scanf_s("%d%d", &x, &y);
		human_player_play(x, y, chessboard, color);
		print_chessboard(chessboard);
		if (color == victory_condition(chessboard)) {
			printf("You Win!\n");
			MessageBox(0, TEXT("You win! Congratulations!"), TEXT("GameOver"), NULL);
			break;
		}
		SPACE AI=AI_player_optimized(chessboard, AI_color);
		print_chessboard(chessboard);
		if (AI_color == victory_condition(chessboard)) {
			printf("AI Win!\n");
			MessageBox(0, TEXT("You lost! What a pity!"), TEXT("GameOver"), NULL);
			break;
		}
		printf("AI choose stone place(%d,%d).\n", AI.x, AI.y);
		printf("It's your turn!\n");
	}
	//*/
//TEST_27:raylib实现后的重构
	srand((unsigned int)time(NULL));
	InitAudioDevice();
	Image boardImage = LoadImage("./source/OIP.jpg");
	Image ruleImage = LoadImage("./source/rule.jpg");
	Image blackImage = LoadImage("./source/black.jpg");
	Image whiteImage = LoadImage("./source/white.jpg");
	InitWindow(boardImage.width*5, boardImage.height*5, "AI_five_son_play");
	SetTargetFPS(120);
	Texture BoardImage = LoadTextureFromImage(boardImage);
	Texture RuleImage = LoadTextureFromImage(ruleImage);
	Texture BlackImage = LoadTextureFromImage(blackImage);
	Texture WhiteImage = LoadTextureFromImage(whiteImage);
	Vector2 boardPosition = { 0.0f, 0.0f };
	Music bgm = LoadMusicStream("./source/music.mp3");
	Sound sound = LoadSound("./source/sound2.wav");
	SetMusicVolume(bgm, 0.5f);
	SetSoundVolume(sound, 10.0f);
	PlayMusicStream(bgm);
	int color = rand() % 2;
	SPACE chessboard[LENGTH][LENGTH] = { 0 };
	for (int i = 0; i < LENGTH; i++) {
		for (int j = 0; j < LENGTH; j++) {
			chessboard[i][j].x = i;
			chessboard[i][j].y = j;
			chessboard[i][j].belong = Blank;
		}
	}
	if (color == White) {
		int x_rand = rand() % 3 + 5, y_rand = rand() % 3 + 5;
		chessboard[x_rand][y_rand].belong = Black;
	}
	int AI_color = (color == White) ? Black : White;
	Color col= (color == White) ? WHITE : BLACK;
	int current_state = RULE_UI;
	int column=0, line=0;
	int x=0, y=0;
	bool left_button_pressed = false;
	while (!WindowShouldClose()) {

		if (IsKeyDown(KEY_ESCAPE)) {
			break;
		}
		if (IsMouseButtonPressed(MOUSE_BUTTON_LEFT) && current_state == GAMETIME) {
			x = GetMouseX();
			y = GetMouseY();
			column = (x - 14) / 92;
			line = (y - 74) / 92;
			left_button_pressed = true; 
		}
		if (current_state != GAMETIME && IsMouseButtonPressed(MOUSE_RIGHT_BUTTON)) {
			switch (current_state) {
			case RULE_UI:
				current_state = (color == Black) ? BLACK_UI : WHITE_UI;
				break;
			case BLACK_UI:
			case WHITE_UI:
				current_state = GAMETIME;
				break;
			}
		}
		BeginDrawing();
		switch (current_state) {
		case RULE_UI:
			DrawTextureEx(RuleImage, boardPosition, 0.0f, 1.0f, WHITE);
			break;
		case BLACK_UI:
			DrawTextureEx(BlackImage, boardPosition, 0.0f, 1.0f, WHITE);
			break;
		case WHITE_UI:
			DrawTextureEx(WhiteImage, boardPosition, 0.0f, 1.0f, WHITE);
			break;
		case GAMETIME:
			DrawTextureEx(BoardImage, boardPosition, 0.0f, 5.0f, WHITE);
			if (line >= 0 && line < LENGTH && column >= 0 && column < LENGTH) {
				DrawCircle(60 + 92 * column, 120 + 92 * line, 40, col);
			}
			for (int i = 0; i < LENGTH; i++) {
				for (int j = 0; j < LENGTH; j++) {
					if (chessboard[i][j].belong == Black) {
						DrawCircle(60 + 92 * j, 120 + 92 * i, 40, BLACK);
					}
					else if (chessboard[i][j].belong == White) {
						DrawCircle(60 + 92 * j, 120 + 92 * i, 40, WHITE);
					}
				}
			}
			if (IsMouseButtonPressed(MOUSE_RIGHT_BUTTON) && left_button_pressed) {
				if (line >= 0 && line < LENGTH && column >= 0 && column < LENGTH) {
					if (chessboard[line][column].belong == Blank) {
						chessboard[line][column].belong = color;
						PlaySound(sound);
						if (color == victory_condition(chessboard)) {
							current_state = WIN_UI;
						}
						else {
							SPACE AI = AI_player_optimized(chessboard, AI_color);
							if (AI.x >= 0 && AI.x < LENGTH && AI.y >= 0 && AI.y < LENGTH) {
								chessboard[AI.x][AI.y].belong = AI_color;
							}
							if (AI_color == victory_condition(chessboard)) {
								current_state = LOSE_UI;
							}
						}
					}
				}
			}
			break;
		case WIN_UI:
			DrawText("You win!Congratulations!", 10, 10, 115, BLACK);
			break;
		case LOSE_UI:
			DrawText("You lose!What a pity!", 10, 10, 130, BLACK);
			break;
		}
		EndDrawing();
		UpdateMusicStream(bgm);
		ClearBackground(RAYWHITE);
	}
	UnloadTexture(BoardImage);
	UnloadTexture(RuleImage);
	UnloadTexture(BlackImage);
	UnloadTexture(WhiteImage);
	StopMusicStream(bgm);
	UnloadMusicStream(bgm);
	UnloadSound(sound);
	CloseAudioDevice();
	CloseWindow();